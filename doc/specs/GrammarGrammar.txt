grammar name GrammarGrammar spectype LALR1 1.0

# This grammar will not actually compile; it is retained as a record of the
# old "native" input format's grammar.

term nonterm_tok :[^ ^$\t\n]+
token nonterm_tok class {} precedence submits to {} dominates {} prefix {} code @
     if(reporter.willHaveEffect(edu.umn.cs.melt.copper.runtime.auxiliary.ErrorDegree.DEGREE_NOTA_BENE) &&
      (dotCounter = (dotCounter + 1) % edu.umn.cs.melt.copper.compiletime.abstractsyntax.intermediate.syntaxtranslator.MasterController.AST_DOT_WINDOW) == 0) reporter.reportRaw(edu.umn.cs.melt.copper.runtime.auxiliary.ErrorDegree.DEGREE_NOTA_BENE,"",".");
     RESULT = edu.umn.cs.melt.copper.runtime.auxiliary.Pair.cons(_pos,lexeme);
@
term terminal_tok :[^ ^$\t\n]+
token terminal_tok class {} precedence submits to {} dominates {} prefix {} code @
    if(reporter.willHaveEffect(edu.umn.cs.melt.copper.runtime.auxiliary.ErrorDegree.DEGREE_NOTA_BENE) &&
      (dotCounter = (dotCounter + 1) % edu.umn.cs.melt.copper.compiletime.abstractsyntax.intermediate.syntaxtranslator.MasterController.AST_DOT_WINDOW) == 0) reporter.reportRaw(edu.umn.cs.melt.copper.runtime.auxiliary.ErrorDegree.DEGREE_NOTA_BENE,"",".");
    RESULT = lexeme;
@
term symbol_tok :[^ ^$\t\n]+
token symbol_tok class {} precedence submits to {} dominates {} prefix {} code @
    if(reporter.willHaveEffect(edu.umn.cs.melt.copper.runtime.auxiliary.ErrorDegree.DEGREE_NOTA_BENE) &&
      (dotCounter = (dotCounter + 1) % edu.umn.cs.melt.copper.compiletime.abstractsyntax.intermediate.syntaxtranslator.MasterController.AST_DOT_WINDOW) == 0) reporter.reportRaw(edu.umn.cs.melt.copper.runtime.auxiliary.ErrorDegree.DEGREE_NOTA_BENE,"",".");
    RESULT = lexeme;
@
term prodname_tok :[^ ^$\t\n]+
token prodname_tok class {} precedence submits to {} dominates {} prefix {} code @
    if(reporter.willHaveEffect(edu.umn.cs.melt.copper.runtime.auxiliary.ErrorDegree.DEGREE_NOTA_BENE) &&
      (dotCounter = (dotCounter + 1) % edu.umn.cs.melt.copper.compiletime.abstractsyntax.intermediate.syntaxtranslator.MasterController.AST_DOT_WINDOW) == 0) reporter.reportRaw(edu.umn.cs.melt.copper.runtime.auxiliary.ErrorDegree.DEGREE_NOTA_BENE,"",".");
    RESULT = lexeme;
@
term attrname_tok :[^ ^$\t\n]+
token attrname_tok class {} precedence submits to {} dominates {} prefix {} code @
    if(reporter.willHaveEffect(edu.umn.cs.melt.copper.runtime.auxiliary.ErrorDegree.DEGREE_NOTA_BENE) &&
      (dotCounter = (dotCounter + 1) % edu.umn.cs.melt.copper.compiletime.abstractsyntax.intermediate.syntaxtranslator.MasterController.AST_DOT_WINDOW) == 0) reporter.reportRaw(edu.umn.cs.melt.copper.runtime.auxiliary.ErrorDegree.DEGREE_NOTA_BENE,"",".");
    RESULT = lexeme;
@
term groupname_tok :[^ ^$\t\n]+
token groupname_tok class {} precedence submits to {} dominates {} prefix {} code @
    if(reporter.willHaveEffect(edu.umn.cs.melt.copper.runtime.auxiliary.ErrorDegree.DEGREE_NOTA_BENE) &&
      (dotCounter = (dotCounter + 1) % edu.umn.cs.melt.copper.compiletime.abstractsyntax.intermediate.syntaxtranslator.MasterController.AST_DOT_WINDOW) == 0) reporter.reportRaw(edu.umn.cs.melt.copper.runtime.auxiliary.ErrorDegree.DEGREE_NOTA_BENE,"",".");
    RESULT = lexeme;
@
term precclass_tok :[^ ^$\t\n]+
token precclass_tok class {} precedence submits to {} dominates {} prefix {} code @
    if(reporter.willHaveEffect(edu.umn.cs.melt.copper.runtime.auxiliary.ErrorDegree.DEGREE_NOTA_BENE) &&
      (dotCounter = (dotCounter + 1) % edu.umn.cs.melt.copper.compiletime.abstractsyntax.intermediate.syntaxtranslator.MasterController.AST_DOT_WINDOW) == 0) reporter.reportRaw(edu.umn.cs.melt.copper.runtime.auxiliary.ErrorDegree.DEGREE_NOTA_BENE,"",".");
    RESULT = lexeme;
@
term grammarname_tok :[^ ^$\t\n]+
token grammarname_tok class {} precedence submits to {} dominates {} prefix {} code @
    if(reporter.willHaveEffect(edu.umn.cs.melt.copper.runtime.auxiliary.ErrorDegree.DEGREE_NOTA_BENE) &&
      (dotCounter = (dotCounter + 1) % edu.umn.cs.melt.copper.compiletime.abstractsyntax.intermediate.syntaxtranslator.MasterController.AST_DOT_WINDOW) == 0) reporter.reportRaw(edu.umn.cs.melt.copper.runtime.auxiliary.ErrorDegree.DEGREE_NOTA_BENE,"",".");
    RESULT = lexeme;
@
term prec_number :0|([1-9][0-9]*)
token prec_number class {} precedence submits to {} dominates {} prefix {} code @ RESULT = Integer.parseInt(lexeme); @

term comment_line :([ \t]+)|(#.*)
token comment_line class {} precedence submits to {} dominates {} prefix {} code @ RESULT = lexeme; @

term t_decl :term
token t_decl class {} precedence submits to {} dominates {} prefix {} code @ RESULT = _pos; @

term tok_decl :token
token tok_decl class {} precedence submits to {} dominates {} prefix {} code @ RESULT = _pos; @

term nt_decl :nonterm
token nt_decl class {} precedence submits to {} dominates {} prefix {} code @ RESULT = _pos; @

term prec_decl :precedence
token prec_decl class {} precedence submits to {} dominates {} prefix {} code @ RESULT = lexeme; @

term submits_decl :submits to
token submits_decl class {} precedence submits to {} dominates {} prefix {} code @ RESULT = lexeme; @

term dominates_decl :dominates
token dominates_decl class {} precedence submits to {} dominates {} prefix {} code @ RESULT = lexeme; @

term prefix_decl :prefix
token prefix_decl class {} precedence submits to {} dominates {} prefix {} code @ RESULT = lexeme; @

#term static_decl :static
#token static_decl class {} precedence submits to {} dominates {} prefix {} code @ RESULT = lexeme; @

#term dynamic_decl :dynamic
#token dynamic_decl class {} precedence submits to {} dominates {} prefix {} code @ RESULT = lexeme; @

#term bridging_decl :bridging
#token bridging_decl class {} precedence submits to {} dominates {} prefix {} code @ RESULT = lexeme; @

term default_decl :default
token default_decl class {} precedence submits to {} dominates {} prefix {} code @ RESULT = lexeme; @

#term matchtype_decl :matchtype
#token matchtype_decl class {} precedence submits to {} dominates {} prefix {} code @ RESULT = lexeme; @

#term matchtypes :(longest)|(shortest)|(all)
#token matchtypes class {} precedence submits to {} dominates {} prefix {} code @ RESULT = lexeme; @

term operator_decl :operator
token operator_decl class {} precedence submits to {} dominates {} prefix {} code @ RESULT = _pos; @

term assoc_decl :associativity
token assoc_decl class {} precedence submits to {} dominates {} prefix {} code @ RESULT = lexeme; @

term assoctypes :(left)|(right)|(nonassoc)
token assoctypes class {} precedence submits to {} dominates {} prefix {} code @
   if(lexeme.equals("nonassoc")) RESULT = edu.umn.cs.melt.copper.compiletime.abstractsyntax.grammar.OperatorAttributes.ASSOC_NONASSOC;
   else if(lexeme.equals("left")) RESULT = edu.umn.cs.melt.copper.compiletime.abstractsyntax.grammar.OperatorAttributes.ASSOC_LEFT;
   else /* if(lexeme.equals("right")) */ RESULT = edu.umn.cs.melt.copper.compiletime.abstractsyntax.grammar.OperatorAttributes.ASSOC_RIGHT;
@

term prod_decl :prod
token prod_decl class {} precedence submits to {} dominates {} prefix {} code @ RESULT = _pos; @

term precclass_decl :class
token precclass_decl class {} precedence submits to {} dominates {} prefix {} code @ RESULT = lexeme; @

term layout_decl :layout
token layout_decl class {} precedence submits to {} dominates {} prefix {} code @ RESULT = lexeme; @

term bnf_decl :bnf
token bnf_decl class {} precedence submits to {} dominates {} prefix {} code @ RESULT = lexeme; @

term goesto :\->
token goesto class {} precedence submits to {} dominates {} prefix {} code @ RESULT = lexeme; @

term attr_decl :attribute
token attr_decl class {} precedence submits to {} dominates {} prefix {} code @ RESULT = lexeme; @

term attr_type_decl :type
token attr_type_decl class {} precedence submits to {} dominates {} prefix {} code @ RESULT = lexeme; @

term code_decl :code
token code_decl class {} precedence submits to {} dominates {} prefix {} code @ RESULT = lexeme; @

term attr_type_base :(Integer)|(Float)|(String)
token attr_type_base class {} precedence submits to {} dominates {} prefix {} code @ RESULT = lexeme; @

term embedded_code :@[^@]*@
token embedded_code class {} precedence submits to {} dominates {} prefix {} code @ RESULT = lexeme.substring(1,lexeme.length() - 1); @

term ambiguous_decl :ambiguous
token ambiguous_decl class {} precedence submits to {} dominates {} prefix {} code @ RESULT = _pos; @

term group_decl :group
token group_decl class {} precedence submits to {} dominates {} prefix {} code @ RESULT = lexeme; @

term members_decl :members
token members_decl class {} precedence submits to {} dominates {} prefix {} code @ RESULT = lexeme; @

term start_decl :start
token start_decl class {} precedence submits to {} dominates {} prefix {} code @ RESULT = _pos; @

term plus :\+
token plus class {} precedence submits to {} dominates {} prefix {} code @ RESULT = lexeme; @

term star :\*
token star class {} precedence submits to {} dominates {} prefix {} code @ RESULT = lexeme; @

term question :\?
token question class {} precedence submits to {} dominates {} prefix {} code @ RESULT = lexeme; @

term bar :\|
token bar class {} precedence submits to {} dominates {} prefix {} code @ RESULT = lexeme; @

term dash :\-
token dash class {} precedence submits to {} dominates {} prefix {} code @ RESULT = lexeme; @

term colon :\:
token colon class {} precedence submits to {} dominates {} prefix {} code @ RESULT = lexeme; @

term not :\^
token not class {} precedence submits to {} dominates {} prefix {} code @ RESULT = lexeme; @

term lbrack :\[
token lbrack class {} precedence submits to {} dominates {} prefix {} code @ RESULT = lexeme; @

term rbrack :\]
token rbrack class {} precedence submits to {} dominates {} prefix {} code @ RESULT = lexeme; @

term lparen :\(
token lparen class {} precedence submits to {} dominates {} prefix {} code @ RESULT = lexeme; @

term rparen :\)
token rparen class {} precedence submits to {} dominates {} prefix {} code @ RESULT = lexeme; @

term lbrace :\{
token lbrace class {} precedence submits to {} dominates {} prefix {} code @ RESULT = lexeme; @

term rbrace :\}
token rbrace class {} precedence submits to {} dominates { precclass_tok symbol_tok terminal_tok } prefix {} code @ RESULT = lexeme; @

term wildcard :\.
token wildcard class {} precedence submits to {} dominates {} prefix {} code @ RESULT = lexeme; @

term character :.
token character class {} precedence submits to {} dominates {} prefix {} code @ RESULT = lexeme; @

term termname :[^\:]+
token termname class {} precedence submits to {} dominates {} prefix {} code @ RESULT = lexeme; @

term escaped :\\.
token escaped class {} precedence submits to {} dominates {} prefix {} code @
    char escapedChar = edu.umn.cs.melt.copper.runtime.auxiliary.QuotedStringFormatter.getRepresentedCharacter(lexeme);
    if(escapedChar == edu.umn.cs.melt.copper.runtime.io.ScannerBuffer.EOFIndicator) error(_pos,"Illegal escaped character");
    RESULT = String.valueOf(escapedChar);
@

term ws :[ \t]*
token ws class {} precedence submits to {} dominates {} prefix {} code @ RESULT = lexeme; @

term newline :[\n]+
token newline class {} precedence submits to {} dominates {} prefix {} code @ RESULT = lexeme; @

term grammar_decl :grammar
token grammar_decl class {} precedence submits to {} dominates {} prefix {} code @ RESULT = _pos; @

term grammar_name_decl :name
token grammar_name_decl class {} precedence submits to {} dominates {} prefix {} code @ RESULT = lexeme; @

term spectype_decl :spectype
token spectype_decl class {} precedence submits to {} dominates {} prefix {} code @ RESULT = lexeme; @

term spectypes :(LALR1)|(LALR1-silver\.haskell)|(LALR1-pretty)
token spectypes class {} precedence submits to {} dominates {} prefix {} code @ RESULT = lexeme; @

term grammar_version :[0-9]+\.[0-9]+
token grammar_version class {} precedence submits to {} dominates {} prefix {} code @ RESULT = lexeme; @

nonterm GrammarFile Grammar NTLine NTSeq TSeq PrecClassSeq TLine TokLine OpLine ProdLine StartLine AttrLine GroupLine DefaultTCodeLine DefaultProdCodeLine SymSeq Regex_Root
nonterm AttrTypeRoot

nonterm Regex_R Regex_DR Regex_UR Regex_RR Regex_G Regex_RG Regex_UG Regex_CHAR

ambiguous term group char1  code @ return lparen;   @ members lparen character
ambiguous term group char2  code @ return rparen;   @ members rparen character
ambiguous term group char3  code @ return wildcard; @ members wildcard character
ambiguous term group char4  code @ return lbrack;   @ members lbrack character
ambiguous term group char5  code @ return rbrack;   @ members rbrack character
ambiguous term group char6  code @ return bar;      @ members bar character
ambiguous term group char7  code @ return question; @ members question character
ambiguous term group char8  code @ return star;     @ members star character
ambiguous term group char9  code @ return dash;     @ members dash character
ambiguous term group char10 code @ return not;      @ members not character
ambiguous term group char11 code @ return colon;    @ members colon character
ambiguous term group char12 code @ return plus;     @ members plus character

attribute dotCounter type Integer code @ dotCounter = 0; @

start GrammarFile layout { ws }

prod GrammarFiletoGrammar  class main precedence 1 operator {} layout { ws } code @
    edu.umn.cs.melt.copper.runtime.io.InputPosition pos = (edu.umn.cs.melt.copper.runtime.io.InputPosition) _children[0];
    String spectype = (String) _children[4];
    String postParseCode = "";
    if(spectype.equals("LALR1-silver.haskell")) postParseCode = "printParseTree(System.out,false,(edu.umn.cs.melt.copper.runtime.parsetree.stripped.StrippedParseTreeNode) root,\"\");";
    else if(spectype.equals("LALR1-pretty")) postParseCode = "printParseTree(System.out,true,(edu.umn.cs.melt.copper.runtime.parsetree.stripped.StrippedParseTreeNode) root,\"\");";
    RESULT = edu.umn.cs.melt.copper.compiletime.abstractsyntax.intermediate.IntermediateConsNode.cons(
            new edu.umn.cs.melt.copper.compiletime.abstractsyntax.intermediate.IntermediateSymbolNode(
             edu.umn.cs.melt.copper.compiletime.abstractsyntax.intermediate.IntermediateSymbolSort.GRAMMAR_NAME,
             edu.umn.cs.melt.copper.compiletime.abstractsyntax.grammar.Symbol.symbol((String) _children[2]),
             edu.umn.cs.melt.copper.runtime.auxiliary.Pair.cons(
              "location",
              edu.umn.cs.melt.copper.runtime.auxiliary.Pair.cons(pos,null))),
             edu.umn.cs.melt.copper.runtime.auxiliary.Pair.cons(
              "spectype",
              edu.umn.cs.melt.copper.runtime.auxiliary.Pair.cons(pos,_children[4])),
            edu.umn.cs.melt.copper.compiletime.abstractsyntax.intermediate.IntermediateConsNode.cons(
            new edu.umn.cs.melt.copper.compiletime.abstractsyntax.intermediate.IntermediateSymbolNode(
             edu.umn.cs.melt.copper.compiletime.abstractsyntax.intermediate.IntermediateSymbolSort.DIRECTIVE,
             edu.umn.cs.melt.copper.compiletime.abstractsyntax.grammar.Symbol.symbol(" postParseCode "),
             edu.umn.cs.melt.copper.runtime.auxiliary.Pair.cons(
              "location",
              edu.umn.cs.melt.copper.runtime.auxiliary.Pair.cons(_pos,null)),
             edu.umn.cs.melt.copper.runtime.auxiliary.Pair.cons(
              "code",
              edu.umn.cs.melt.copper.runtime.auxiliary.Pair.cons(_pos,(Object) postParseCode))),
             _children[7]));
@ bnf GrammarFile -> grammar_decl grammar_name_decl grammarname_tok spectype_decl spectypes grammar_version newline Grammar

prod GrammartoNTLine             class main precedence 1 operator {} layout { ws } code @
    RESULT = edu.umn.cs.melt.copper.compiletime.abstractsyntax.intermediate.IntermediateConsNode.cons(_children[0],_children[1]);
@ bnf Grammar -> NTLine Grammar
prod GrammartoTLine              class main precedence 1 operator {} layout { ws } code @
    RESULT = edu.umn.cs.melt.copper.compiletime.abstractsyntax.intermediate.IntermediateConsNode.cons(_children[0],_children[1]);
@ bnf Grammar -> TLine Grammar
prod GrammartoTokLine            class main precedence 1 operator {} layout { ws } code @
    RESULT = edu.umn.cs.melt.copper.compiletime.abstractsyntax.intermediate.IntermediateConsNode.cons(_children[0],_children[1]);
@ bnf Grammar -> TokLine Grammar
prod GrammartoOpLine             class main precedence 1 operator {} layout { ws } code @
    RESULT = edu.umn.cs.melt.copper.compiletime.abstractsyntax.intermediate.IntermediateConsNode.cons(_children[0],_children[1]);
@ bnf Grammar -> OpLine Grammar
prod GrammartoProdLine           class main precedence 1 operator {} layout { ws } code @
    RESULT = edu.umn.cs.melt.copper.compiletime.abstractsyntax.intermediate.IntermediateConsNode.cons(_children[0],_children[1]);
@ bnf Grammar -> ProdLine Grammar
prod GrammartoStartLine          class main precedence 1 operator {} layout { ws } code @
    RESULT = edu.umn.cs.melt.copper.compiletime.abstractsyntax.intermediate.IntermediateConsNode.cons(_children[0],_children[1]);
@ bnf Grammar -> StartLine Grammar
prod GrammartoAttrLine           class main precedence 1 operator {} layout { ws } code @
    RESULT = edu.umn.cs.melt.copper.compiletime.abstractsyntax.intermediate.IntermediateConsNode.cons(_children[0],_children[1]);
@ bnf Grammar -> AttrLine Grammar
prod GrammartoGroupLine          class main precedence 1 operator {} layout { ws } code @
    RESULT = edu.umn.cs.melt.copper.compiletime.abstractsyntax.intermediate.IntermediateConsNode.cons(_children[0],_children[1]);
@ bnf Grammar -> GroupLine Grammar
prod GrammartoDefaultTCodeLine   class main precedence 1 operator {} layout { ws } code @
    RESULT = edu.umn.cs.melt.copper.compiletime.abstractsyntax.intermediate.IntermediateConsNode.cons(_children[0],_children[1]);
@ bnf Grammar -> DefaultTCodeLine Grammar
prod GrammartoDefaultProdCodeLine  class main precedence 1 operator {} layout { ws } code @
    RESULT = edu.umn.cs.melt.copper.compiletime.abstractsyntax.intermediate.IntermediateConsNode.cons(_children[0],_children[1]);
@ bnf Grammar -> DefaultProdCodeLine Grammar
prod GrammartoCommentLine    class main precedence 1 operator {} layout { ws } code @
    RESULT = _children[2];
@ bnf Grammar -> comment_line newline Grammar
prod GrammartoEps            class main precedence 1 operator {} layout { ws } code @
    RESULT = null;
@ bnf Grammar -> eps

prod NTLineMain         class main precedence 1 operator {} layout { ws } code @
    RESULT = _children[1];
@ bnf NTLine -> nt_decl NTSeq newline

prod NTSeqMain          class main precedence 1 operator {} layout { ws } code @
    edu.umn.cs.melt.copper.runtime.io.InputPosition pos = ((edu.umn.cs.melt.copper.runtime.auxiliary.Pair<edu.umn.cs.melt.copper.runtime.io.InputPosition,String>) _children[0]).first();
    Object child0 = new edu.umn.cs.melt.copper.compiletime.abstractsyntax.intermediate.IntermediateSymbolNode(
                     edu.umn.cs.melt.copper.compiletime.abstractsyntax.intermediate.IntermediateSymbolSort.NON_TERMINAL,
                     edu.umn.cs.melt.copper.compiletime.abstractsyntax.grammar.Symbol.symbol(((edu.umn.cs.melt.copper.runtime.auxiliary.Pair<edu.umn.cs.melt.copper.runtime.io.InputPosition,String>) _children[0]).second()),
                     edu.umn.cs.melt.copper.runtime.auxiliary.Pair.cons(
                      "location",
                      edu.umn.cs.melt.copper.runtime.auxiliary.Pair.cons(pos,null)));
    RESULT = edu.umn.cs.melt.copper.compiletime.abstractsyntax.intermediate.IntermediateConsNode.cons(child0,_children[1]);
@ bnf NTSeq -> nonterm_tok NTSeq
prod NTSeqEps           class main precedence 1 operator {} layout { ws } code @
    RESULT = null;
@ bnf NTSeq -> eps

prod TSeqMain          class main precedence 1 operator {} layout { ws } code @
    ((java.util.LinkedList<String>) _children[1]).addFirst((String) _children[0]);
    RESULT = _children[1];
@ bnf TSeq -> terminal_tok TSeq
prod TSeqEps           class main precedence 1 operator {} layout { ws } code @
    RESULT = new java.util.LinkedList<String>();
@ bnf TSeq -> eps

prod TLineMain          class main precedence 1 operator {} layout { ws } code @
    RESULT = new edu.umn.cs.melt.copper.compiletime.abstractsyntax.intermediate.IntermediateSymbolNode(
            edu.umn.cs.melt.copper.compiletime.abstractsyntax.intermediate.IntermediateSymbolSort.TERMINAL,
            edu.umn.cs.melt.copper.compiletime.abstractsyntax.grammar.Symbol.symbol((String) _children[1]),
            edu.umn.cs.melt.copper.runtime.auxiliary.Pair.cons(
             "location",
             edu.umn.cs.melt.copper.runtime.auxiliary.Pair.cons(_pos,null)),
            edu.umn.cs.melt.copper.runtime.auxiliary.Pair.cons(
             "regex",
             edu.umn.cs.melt.copper.runtime.auxiliary.Pair.cons(_pos,_children[2])));
@ bnf TLine -> t_decl terminal_tok Regex_Root

prod TokLineMain        class main precedence 1 operator {} layout { ws } code @
    boolean noPrefix = false;
    if(((java.util.LinkedList<String>) _children[17]).size() > 1) error(_pos,"Terminals cannot have more than one prefix");
    else if(((java.util.LinkedList<String>) _children[17]).isEmpty())
    {
        noPrefix = true;
    }
    java.util.LinkedList<String> classes = (java.util.LinkedList<String>) _children[4];
    edu.umn.cs.melt.copper.compiletime.abstractsyntax.intermediate.IntermediateNode node = null;
    for(String tClass : classes)
    {
        edu.umn.cs.melt.copper.compiletime.abstractsyntax.intermediate.IntermediateSymbolNode newNode =
         new edu.umn.cs.melt.copper.compiletime.abstractsyntax.intermediate.IntermediateSymbolNode(
          edu.umn.cs.melt.copper.compiletime.abstractsyntax.intermediate.IntermediateSymbolSort.TERMINAL_CLASS,
          edu.umn.cs.melt.copper.compiletime.abstractsyntax.grammar.Symbol.symbol(tClass));
        node = edu.umn.cs.melt.copper.compiletime.abstractsyntax.intermediate.IntermediateConsNode.cons(newNode,node);
    }
    RESULT = edu.umn.cs.melt.copper.compiletime.abstractsyntax.intermediate.IntermediateConsNode.cons(
           node,
           new edu.umn.cs.melt.copper.compiletime.abstractsyntax.intermediate.IntermediateSymbolNode(
            edu.umn.cs.melt.copper.compiletime.abstractsyntax.intermediate.IntermediateSymbolSort.TERMINAL,
            edu.umn.cs.melt.copper.compiletime.abstractsyntax.grammar.Symbol.symbol((String) _children[1]),
            edu.umn.cs.melt.copper.runtime.auxiliary.Pair.cons(
             "classes",
             edu.umn.cs.melt.copper.runtime.auxiliary.Pair.cons(_pos,_children[4])),
            edu.umn.cs.melt.copper.runtime.auxiliary.Pair.cons(
             "submits",
             edu.umn.cs.melt.copper.runtime.auxiliary.Pair.cons(_pos,_children[9])),
            edu.umn.cs.melt.copper.runtime.auxiliary.Pair.cons(
             "dominates",
             edu.umn.cs.melt.copper.runtime.auxiliary.Pair.cons(_pos,_children[13])),
            noPrefix ? null : edu.umn.cs.melt.copper.runtime.auxiliary.Pair.cons(
             "prefix",
             edu.umn.cs.melt.copper.runtime.auxiliary.Pair.cons(_pos,(Object) ((java.util.LinkedList<String>) _children[17]).getFirst())),
            edu.umn.cs.melt.copper.runtime.auxiliary.Pair.cons(
             "code",
             edu.umn.cs.melt.copper.runtime.auxiliary.Pair.cons(_pos,_children[20]))));
            
@ bnf TokLine -> tok_decl terminal_tok precclass_decl lbrace PrecClassSeq rbrace prec_decl submits_decl lbrace SymSeq rbrace dominates_decl lbrace SymSeq rbrace prefix_decl lbrace TSeq rbrace code_decl embedded_code newline

prod PrecClassSeqMain   class main precedence 1 operator {} layout { ws } code @
    ((java.util.LinkedList<String>) _children[1]).addFirst((String) _children[0]);
    RESULT = _children[1];
@ bnf PrecClassSeq -> precclass_tok PrecClassSeq
prod PrecClassSeqEps    class main precedence 1 operator {} layout { ws } code @
    RESULT = new java.util.LinkedList<String>();
@ bnf PrecClassSeq -> eps

prod OpLineMain         class main precedence 1 operator {} layout { ws } code @
    edu.umn.cs.melt.copper.runtime.io.InputPosition pos = (edu.umn.cs.melt.copper.runtime.io.InputPosition) _children[0];
    RESULT = edu.umn.cs.melt.copper.compiletime.abstractsyntax.intermediate.IntermediateConsNode.cons(
           new edu.umn.cs.melt.copper.compiletime.abstractsyntax.intermediate.IntermediateSymbolNode(
            edu.umn.cs.melt.copper.compiletime.abstractsyntax.intermediate.IntermediateSymbolSort.TERMINAL_CLASS,
            edu.umn.cs.melt.copper.compiletime.abstractsyntax.grammar.Symbol.symbol((String) _children[3]),
            edu.umn.cs.melt.copper.runtime.auxiliary.Pair.cons(
             "location",
             edu.umn.cs.melt.copper.runtime.auxiliary.Pair.cons(pos,null))),
           new edu.umn.cs.melt.copper.compiletime.abstractsyntax.intermediate.IntermediateSymbolNode(
            edu.umn.cs.melt.copper.compiletime.abstractsyntax.intermediate.IntermediateSymbolSort.TERMINAL,
            edu.umn.cs.melt.copper.compiletime.abstractsyntax.grammar.Symbol.symbol((String) _children[1]),
            edu.umn.cs.melt.copper.runtime.auxiliary.Pair.cons(
             "operatorClass",
             edu.umn.cs.melt.copper.runtime.auxiliary.Pair.cons(_pos,_children[3])),
            edu.umn.cs.melt.copper.runtime.auxiliary.Pair.cons(
             "operatorPrecedence",
             edu.umn.cs.melt.copper.runtime.auxiliary.Pair.cons(_pos,_children[5])),
            edu.umn.cs.melt.copper.runtime.auxiliary.Pair.cons(
             "operatorAssociativity",
             edu.umn.cs.melt.copper.runtime.auxiliary.Pair.cons(_pos,_children[7]))));
@ bnf OpLine -> operator_decl terminal_tok precclass_decl precclass_tok prec_decl prec_number assoc_decl assoctypes newline

prod ProdLineMain       class main precedence 1 operator {} layout { ws } code @
    edu.umn.cs.melt.copper.runtime.io.InputPosition pos = (edu.umn.cs.melt.copper.runtime.io.InputPosition) _children[0];
    boolean noOperator = false;
    if(((java.util.LinkedList<String>) _children[8]).size() > 1) error(_pos,"Productions cannot have more than one custom operator");
    else if(((java.util.LinkedList<String>) _children[8]).isEmpty()) noOperator = true;
    RESULT = edu.umn.cs.melt.copper.compiletime.abstractsyntax.intermediate.IntermediateConsNode.cons(
           new edu.umn.cs.melt.copper.compiletime.abstractsyntax.intermediate.IntermediateSymbolNode(
            edu.umn.cs.melt.copper.compiletime.abstractsyntax.intermediate.IntermediateSymbolSort.TERMINAL_CLASS,
            edu.umn.cs.melt.copper.compiletime.abstractsyntax.grammar.Symbol.symbol((String) _children[3]),
            edu.umn.cs.melt.copper.runtime.auxiliary.Pair.cons(
             "location",
             edu.umn.cs.melt.copper.runtime.auxiliary.Pair.cons(pos,null))),
           new edu.umn.cs.melt.copper.compiletime.abstractsyntax.intermediate.IntermediateSymbolNode(
            edu.umn.cs.melt.copper.compiletime.abstractsyntax.intermediate.IntermediateSymbolSort.PRODUCTION,
            edu.umn.cs.melt.copper.compiletime.abstractsyntax.grammar.Symbol.symbol((String) _children[1]),
            edu.umn.cs.melt.copper.runtime.auxiliary.Pair.cons(
             "location",
             edu.umn.cs.melt.copper.runtime.auxiliary.Pair.cons(pos,null)),
            edu.umn.cs.melt.copper.runtime.auxiliary.Pair.cons(
             "class",
             edu.umn.cs.melt.copper.runtime.auxiliary.Pair.cons(pos,_children[3])),
            edu.umn.cs.melt.copper.runtime.auxiliary.Pair.cons(
             "precedence",
             edu.umn.cs.melt.copper.runtime.auxiliary.Pair.cons(pos,_children[5])),
            noOperator ? null : edu.umn.cs.melt.copper.runtime.auxiliary.Pair.cons(
             "operator",
             edu.umn.cs.melt.copper.runtime.auxiliary.Pair.cons(pos,(Object) ((java.util.LinkedList<String>) _children[8]).getFirst())),
            edu.umn.cs.melt.copper.runtime.auxiliary.Pair.cons(
             "layout",
             edu.umn.cs.melt.copper.runtime.auxiliary.Pair.cons(pos,_children[12])),
            edu.umn.cs.melt.copper.runtime.auxiliary.Pair.cons(
             "code",
             edu.umn.cs.melt.copper.runtime.auxiliary.Pair.cons(pos,_children[15])),
            edu.umn.cs.melt.copper.runtime.auxiliary.Pair.cons(
             "LHS",
             edu.umn.cs.melt.copper.runtime.auxiliary.Pair.cons(pos,(Object) ((edu.umn.cs.melt.copper.runtime.auxiliary.Pair<edu.umn.cs.melt.copper.runtime.io.InputPosition,String>) _children[17]).second())),
            edu.umn.cs.melt.copper.runtime.auxiliary.Pair.cons(
             "RHS",
             edu.umn.cs.melt.copper.runtime.auxiliary.Pair.cons(pos,_children[19]))));
@ bnf ProdLine -> prod_decl prodname_tok precclass_decl precclass_tok prec_decl prec_number operator_decl lbrace TSeq rbrace layout_decl lbrace TSeq rbrace code_decl embedded_code bnf_decl nonterm_tok goesto SymSeq newline

prod StartLineMain      class main precedence 1 operator {} layout { ws } code @
    edu.umn.cs.melt.copper.runtime.io.InputPosition pos = (edu.umn.cs.melt.copper.runtime.io.InputPosition) _children[0];
    RESULT = new edu.umn.cs.melt.copper.compiletime.abstractsyntax.intermediate.IntermediateSymbolNode(
            edu.umn.cs.melt.copper.compiletime.abstractsyntax.intermediate.IntermediateSymbolSort.NON_TERMINAL,
            edu.umn.cs.melt.copper.compiletime.abstractsyntax.grammar.Symbol.symbol(((edu.umn.cs.melt.copper.runtime.auxiliary.Pair<edu.umn.cs.melt.copper.runtime.io.InputPosition,String>) _children[1]).second()),
            edu.umn.cs.melt.copper.runtime.auxiliary.Pair.cons(
             "startLayout",
             edu.umn.cs.melt.copper.runtime.auxiliary.Pair.cons(pos,_children[4])),
            edu.umn.cs.melt.copper.runtime.auxiliary.Pair.cons(
             "isStart",
             edu.umn.cs.melt.copper.runtime.auxiliary.Pair.cons(pos,(Object) new Boolean(true))));
@ bnf StartLine -> start_decl nonterm_tok layout_decl lbrace TSeq rbrace newline

prod AttrLineMain       class main precedence 1 operator {} layout { ws } code @
    RESULT = new edu.umn.cs.melt.copper.compiletime.abstractsyntax.intermediate.IntermediateSymbolNode(
            edu.umn.cs.melt.copper.compiletime.abstractsyntax.intermediate.IntermediateSymbolSort.PARSER_ATTRIBUTE,
            edu.umn.cs.melt.copper.compiletime.abstractsyntax.grammar.Symbol.symbol((String) _children[1]),
            edu.umn.cs.melt.copper.runtime.auxiliary.Pair.cons(
             "location",
             edu.umn.cs.melt.copper.runtime.auxiliary.Pair.cons(_pos,null)),
            edu.umn.cs.melt.copper.runtime.auxiliary.Pair.cons(
             "type",
             edu.umn.cs.melt.copper.runtime.auxiliary.Pair.cons(_pos,_children[3])),
            edu.umn.cs.melt.copper.runtime.auxiliary.Pair.cons(
             "code",
             edu.umn.cs.melt.copper.runtime.auxiliary.Pair.cons(_pos,_children[5])));
@ bnf AttrLine -> attr_decl attrname_tok attr_type_decl AttrTypeRoot code_decl embedded_code newline

prod AttrTypeList       class main precedence 1 operator {} layout { ws } code @
     RESULT = "java.util.LinkedList< " + _children[1] + " >";
@ bnf AttrTypeRoot -> lbrack AttrTypeRoot rbrack
prod AttrTypeBase       class main precedence 1 operator {} layout { ws } code @
    RESULT = _children[0];
@ bnf AttrTypeRoot -> attr_type_base

prod GroupLineMain      class main precedence 1 operator {} layout { ws } code @
    RESULT = new edu.umn.cs.melt.copper.compiletime.abstractsyntax.intermediate.IntermediateSymbolNode(
            edu.umn.cs.melt.copper.compiletime.abstractsyntax.intermediate.IntermediateSymbolSort.DISAMBIGUATION_GROUP,
            edu.umn.cs.melt.copper.compiletime.abstractsyntax.grammar.Symbol.symbol((String) _children[3]),
            edu.umn.cs.melt.copper.runtime.auxiliary.Pair.cons(
             "location",
             edu.umn.cs.melt.copper.runtime.auxiliary.Pair.cons(_pos,null)),
            edu.umn.cs.melt.copper.runtime.auxiliary.Pair.cons(
             "code",
             edu.umn.cs.melt.copper.runtime.auxiliary.Pair.cons(_pos,_children[5])),
            edu.umn.cs.melt.copper.runtime.auxiliary.Pair.cons(
             "members",
             edu.umn.cs.melt.copper.runtime.auxiliary.Pair.cons(_pos,_children[7])));
@ bnf GroupLine -> ambiguous_decl t_decl group_decl groupname_tok code_decl embedded_code members_decl TSeq newline

prod DefaultTCodeLineMain class main precedence 1 operator {} layout { ws } code @
    RESULT = new edu.umn.cs.melt.copper.compiletime.abstractsyntax.intermediate.IntermediateSymbolNode(
            edu.umn.cs.melt.copper.compiletime.abstractsyntax.intermediate.IntermediateSymbolSort.DIRECTIVE,
            edu.umn.cs.melt.copper.compiletime.abstractsyntax.grammar.Symbol.symbol(" defaultTermCode "),
            edu.umn.cs.melt.copper.runtime.auxiliary.Pair.cons(
             "location",
             edu.umn.cs.melt.copper.runtime.auxiliary.Pair.cons(_pos,null)),
            edu.umn.cs.melt.copper.runtime.auxiliary.Pair.cons(
             "code",
             edu.umn.cs.melt.copper.runtime.auxiliary.Pair.cons(_pos,_children[3])));
@ bnf DefaultTCodeLine -> default_decl t_decl code_decl embedded_code newline

prod DefaultProdCodeLineMain class main precedence 1 operator {} layout { ws } code @
    RESULT = new edu.umn.cs.melt.copper.compiletime.abstractsyntax.intermediate.IntermediateSymbolNode(
            edu.umn.cs.melt.copper.compiletime.abstractsyntax.intermediate.IntermediateSymbolSort.DIRECTIVE,
            edu.umn.cs.melt.copper.compiletime.abstractsyntax.grammar.Symbol.symbol(" defaultProdCode "),
            edu.umn.cs.melt.copper.runtime.auxiliary.Pair.cons(
             "location",
             edu.umn.cs.melt.copper.runtime.auxiliary.Pair.cons(_pos,null)),
            edu.umn.cs.melt.copper.runtime.auxiliary.Pair.cons(
             "code",
             edu.umn.cs.melt.copper.runtime.auxiliary.Pair.cons(_pos,_children[3])));
@ bnf DefaultProdCodeLine -> default_decl prod_decl code_decl embedded_code newline

prod SymSeqMain         class main precedence 1 operator {} layout { ws } code @
    ((java.util.LinkedList<String>) _children[1]).addFirst((String) _children[0]);
    RESULT = _children[1];
@ bnf SymSeq -> symbol_tok SymSeq
prod SymSeqEps          class main precedence 1 operator {} layout { ws } code @
    RESULT = new java.util.LinkedList<String>();
@ bnf SymSeq -> eps

prod RoottoR            class main precedence 1 operator {} layout {} code @
    RESULT = _children[1];
@ bnf Regex_Root -> colon Regex_R newline
prod Roottoeps          class main precedence 1 operator {} layout {} code @
    RESULT = new edu.umn.cs.melt.copper.compiletime.abstractsyntax.regex.EmptyString();
@ bnf Regex_Root -> colon newline

prod RtoDR              class regex precedence 1 operator {} layout {} code @
    RESULT = _children[0];
@ bnf Regex_R -> Regex_DR
prod RtoDR_bar_R        class regex precedence 1 operator {} layout {} code @
    RESULT = new edu.umn.cs.melt.copper.compiletime.abstractsyntax.regex.Choice(
            (edu.umn.cs.melt.copper.compiletime.abstractsyntax.regex.ParsedRegex) _children[0],
            (edu.umn.cs.melt.copper.compiletime.abstractsyntax.regex.ParsedRegex) _children[2]);
@ bnf  Regex_R -> Regex_DR bar Regex_R
prod DRtoUR_RR           class regex precedence 1 operator {} layout {} code @
    RESULT = new edu.umn.cs.melt.copper.compiletime.abstractsyntax.regex.Concatenation(
            (edu.umn.cs.melt.copper.compiletime.abstractsyntax.regex.ParsedRegex) _children[0],
            (edu.umn.cs.melt.copper.compiletime.abstractsyntax.regex.ParsedRegex) _children[1]);
@ bnf  Regex_DR -> Regex_UR Regex_RR
prod DRtoUR_star_RR      class regex precedence 1 operator {} layout {} code @
    RESULT = new edu.umn.cs.melt.copper.compiletime.abstractsyntax.regex.Concatenation(
            new edu.umn.cs.melt.copper.compiletime.abstractsyntax.regex.KleeneStar(
             (edu.umn.cs.melt.copper.compiletime.abstractsyntax.regex.ParsedRegex) _children[0]),
            (edu.umn.cs.melt.copper.compiletime.abstractsyntax.regex.ParsedRegex) _children[2]);
@ bnf  Regex_DR -> Regex_UR star Regex_RR
prod DRtoUR_plus_RR      class regex precedence 1 operator {} layout {} code @
    RESULT = new edu.umn.cs.melt.copper.compiletime.abstractsyntax.regex.Concatenation(
            new edu.umn.cs.melt.copper.compiletime.abstractsyntax.regex.Concatenation(
             (edu.umn.cs.melt.copper.compiletime.abstractsyntax.regex.ParsedRegex) _children[0]),
            new edu.umn.cs.melt.copper.compiletime.abstractsyntax.regex.KleeneStar(
             ((edu.umn.cs.melt.copper.compiletime.abstractsyntax.regex.ParsedRegex) _children[0]).clone()),
            (edu.umn.cs.melt.copper.compiletime.abstractsyntax.regex.ParsedRegex) _children[2]);
@ bnf  Regex_DR -> Regex_UR plus Regex_RR
prod DRtoUR_question_RR  class regex precedence 1 operator {} layout {} code @
    RESULT = new edu.umn.cs.melt.copper.compiletime.abstractsyntax.regex.Concatenation(
            new edu.umn.cs.melt.copper.compiletime.abstractsyntax.regex.Choice(
             new edu.umn.cs.melt.copper.compiletime.abstractsyntax.regex.EmptyString(),
             (edu.umn.cs.melt.copper.compiletime.abstractsyntax.regex.ParsedRegex) _children[0]),
            (edu.umn.cs.melt.copper.compiletime.abstractsyntax.regex.ParsedRegex) _children[2]);
@ bnf  Regex_DR -> Regex_UR question Regex_RR
prod RRtoDR              class regex precedence 1 operator {} layout {} code @
    RESULT = _children[0];
@ bnf  Regex_RR -> Regex_DR
prod RRtoeps            class regex precedence 1 operator {} layout {} code @
    RESULT = new edu.umn.cs.melt.copper.compiletime.abstractsyntax.regex.EmptyString();
@ bnf  Regex_RR -> eps


prod URtoCHAR           class regex precedence 1 operator {} layout {} code @
    RESULT = _children[0];
@ bnf  Regex_UR -> Regex_CHAR
prod URtowildcard       class regex precedence 1 operator {} layout {} code @
	edu.umn.cs.melt.copper.compiletime.abstractsyntax.regex.CharacterSet Newline =
	       new edu.umn.cs.melt.copper.compiletime.abstractsyntax.regex.CharacterSet(
	        edu.umn.cs.melt.copper.compiletime.abstractsyntax.regex.CharacterSet.LOOSE_CHARACTERS,'\n');
    RESULT = Newline.invertSet();
@ bnf  Regex_UR -> wildcard
prod URtolb_G_rb        class regex precedence 1 operator {} layout {} code @
    RESULT = _children[1];
@ bnf  Regex_UR -> lbrack Regex_G rbrack
prod URtolb_not_G_rb    class regex precedence 1 operator {} layout {} code @
    if(_children[2] instanceof edu.umn.cs.melt.copper.compiletime.abstractsyntax.regex.CharacterSet)
	{
		edu.umn.cs.melt.copper.compiletime.abstractsyntax.regex.CharacterSet CGNode =
		   (edu.umn.cs.melt.copper.compiletime.abstractsyntax.regex.CharacterSet) _children[2];
		RESULT = CGNode.invertSet();
	}
	else
	{
		error(_pos,"Type error in regex");
		RESULT = null;
	}
@ bnf  Regex_UR -> lbrack not Regex_G rbrack
prod URtomacro          class regex precedence 1 operator {} layout {} code @
    RESULT = new edu.umn.cs.melt.copper.compiletime.abstractsyntax.regex.MacroHole(
            new edu.umn.cs.melt.copper.compiletime.abstractsyntax.grammar.Terminal((String) _children[2]));
@ bnf  Regex_UR -> lbrack colon termname colon rbrack
prod URtolp_R_rp        class regex precedence 1 operator {} layout {} code @
    RESULT = _children[1];
@ bnf  Regex_UR -> lparen Regex_R rparen
prod GtoUG_RG           class regex precedence 1 operator {} layout {} code @
	edu.umn.cs.melt.copper.compiletime.abstractsyntax.regex.ParsedRegex UGNode =
		(edu.umn.cs.melt.copper.compiletime.abstractsyntax.regex.ParsedRegex) _children[0];
	edu.umn.cs.melt.copper.compiletime.abstractsyntax.regex.ParsedRegex RGNode =
		(edu.umn.cs.melt.copper.compiletime.abstractsyntax.regex.ParsedRegex) _children[1];
	
	if(UGNode instanceof edu.umn.cs.melt.copper.compiletime.abstractsyntax.regex.CharacterSet &&
	   (RGNode == null || RGNode instanceof edu.umn.cs.melt.copper.compiletime.abstractsyntax.regex.EmptyString))
	{
		RESULT = UGNode;
	}
	else if(UGNode instanceof edu.umn.cs.melt.copper.compiletime.abstractsyntax.regex.CharacterSet &&
	        RGNode instanceof edu.umn.cs.melt.copper.compiletime.abstractsyntax.regex.CharacterSet)
	{
		RESULT = edu.umn.cs.melt.copper.compiletime.abstractsyntax.regex.CharacterSet.union(
				 (edu.umn.cs.melt.copper.compiletime.abstractsyntax.regex.CharacterSet) UGNode,
				 (edu.umn.cs.melt.copper.compiletime.abstractsyntax.regex.CharacterSet) RGNode);
	}
	else
	{
		error(_pos,"Type error in regex");
		RESULT = new edu.umn.cs.melt.copper.compiletime.abstractsyntax.regex.EmptyString();
	}
@ bnf  Regex_G -> Regex_UG Regex_RG
prod UGtoCHAR           class regex precedence 1 operator {} layout {} code @
    RESULT = _children[0];
@ bnf  Regex_UG -> Regex_CHAR
prod UGtoCHAR_dash_CHAR class regex precedence 1 operator {} layout {} code @
	edu.umn.cs.melt.copper.compiletime.abstractsyntax.regex.ParsedRegex characterNode1 =
		(edu.umn.cs.melt.copper.compiletime.abstractsyntax.regex.ParsedRegex) _children[0];
	edu.umn.cs.melt.copper.compiletime.abstractsyntax.regex.ParsedRegex characterNode2 =
		(edu.umn.cs.melt.copper.compiletime.abstractsyntax.regex.ParsedRegex) _children[2];
	
	if(characterNode1 instanceof edu.umn.cs.melt.copper.compiletime.abstractsyntax.regex.CharacterSet &&
	   characterNode2 instanceof edu.umn.cs.melt.copper.compiletime.abstractsyntax.regex.CharacterSet)
	{
		char lowerLimit = ((edu.umn.cs.melt.copper.compiletime.abstractsyntax.regex.CharacterSet) characterNode1).getFirstChar();
		char upperLimit = ((edu.umn.cs.melt.copper.compiletime.abstractsyntax.regex.CharacterSet) characterNode2).getFirstChar();
		RESULT = new edu.umn.cs.melt.copper.compiletime.abstractsyntax.regex.CharacterSet(
		        edu.umn.cs.melt.copper.compiletime.abstractsyntax.regex.CharacterSet.RANGES,
		        '+',lowerLimit,upperLimit);
	}
	else
	{
		error(_pos,"Type error in regex");
		RESULT = new edu.umn.cs.melt.copper.compiletime.abstractsyntax.regex.CharacterSet(
		        edu.umn.cs.melt.copper.compiletime.abstractsyntax.regex.CharacterSet.LOOSE_CHARACTERS);
	}
@ bnf  Regex_UG -> Regex_CHAR dash Regex_CHAR
prod RGtoG              class regex precedence 1 operator {} layout {} code @
    RESULT = _children[0];
@ bnf  Regex_RG -> Regex_G
prod RGtoeps            class regex precedence 1 operator {} layout {} code @
    RESULT = new edu.umn.cs.melt.copper.compiletime.abstractsyntax.regex.EmptyString();
@ bnf  Regex_RG -> eps
prod CHARtochar         class regex precedence 1 operator {} layout {} code @
    RESULT = new edu.umn.cs.melt.copper.compiletime.abstractsyntax.regex.CharacterSet(
            edu.umn.cs.melt.copper.compiletime.abstractsyntax.regex.CharacterSet.LOOSE_CHARACTERS,
		     (((String) _children[0]).toCharArray()));
@ bnf  Regex_CHAR -> character
prod CHARtoescaped      class regex precedence 1 operator {} layout {} code @
    RESULT = new edu.umn.cs.melt.copper.compiletime.abstractsyntax.regex.CharacterSet(
            edu.umn.cs.melt.copper.compiletime.abstractsyntax.regex.CharacterSet.LOOSE_CHARACTERS,
		     (((String) _children[0]).toCharArray()));
@ bnf  Regex_CHAR -> escaped

