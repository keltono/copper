package edu.umn.cs.melt.copper.compiletime.auxiliary;

import edu.umn.cs.melt.copper.compiletime.lrdfa.LR0DFA;
import edu.umn.cs.melt.copper.compiletime.lrdfa.LR0ItemSet;
import edu.umn.cs.melt.copper.compiletime.spec.numeric.ParserSpec;

import java.util.ArrayList;
import java.util.BitSet;
import java.util.Hashtable;

public class ProductionStepTables {
    /**
     * The production steps for a given StateItem
     * The bitset represents indices into the LR0ItemSet for the associated state
     */
    private Hashtable<StateItem,BitSet> productionStepTable;
    /**
     * The reverse production steps indexed by the state and the non-terminal on the lefthand side of the production
     * Represented by indices into the LR0ItemSet (in the LR0DFA) for the associated state.
     */
    private ArrayList<BitSet>[] reverseProductionStepTable;

    public ProductionStepTables(LR0DFA dfa, ParserSpec spec){
       reverseProductionStepTable = new ArrayList[dfa.size()];
       productionStepTable = new Hashtable<>();
       build(dfa, spec);
    }

    /**
     * build the productionStep and reverseProductionStep tables.
     * <p>
     *     More or less directly translated from the reference implementation.
     *     <a
     *     href="https://github.com/polyglot-compiler/polyglot/blob/3ff2eb01acb952d524c7de2b7f2c1a6d875d6f6d/tools/java_cup/src/parser/StateItem.java#L365"
     *     >
     *     located here.
     *     </a>
     * </p>
     */
    private void build(LR0DFA dfa, ParserSpec spec){
        //fill in the closure map
        //for each state
        for (int state = 0; state < dfa.size(); state++) {
            //mapping of a non-terminal to the (indexes into the) LR0 items that were generated by the closure on that state
            BitSet[] closures = new BitSet[dfa.size()];

            LR0ItemSet curr = dfa.getItemSet(state);
            //for each item in the state
            for (int j = 0; j < curr.size(); j++) {
                //if the current item was generated by a closure
                if(curr.getPosition(j) == 0 && curr.getProduction(j) != spec.getStartProduction()){
                    if(closures[j] == null){
                        closures[j] = new BitSet();
                    }
                    closures[j].set(spec.pr.getLHS(curr.getProduction(j)));
                }
            }
            reverseProductionStepTable[state] = new ArrayList<>();

            //for each item in the state
            for (int item = 0; item < curr.size(); item++) {
                int production = curr.getProduction(item);
                int dotPosition = curr.getPosition(item);
                //do nothing on reduce items
                if (spec.pr.getRHSLength(production) == dotPosition){
                    continue;
                }
                int symbolAfterDot = spec.pr.getRHSSym(production,dotPosition);

                //ignore productions with terminals after their dot
                if(spec.terminals.get(symbolAfterDot)){
                    continue;
                }
                if(closures[item] != null){
                    StateItem srcStateItem = new StateItem(state,curr.getProduction(item), curr.getPosition(item));
                    if(productionStepTable.get(srcStateItem) == null){
                        productionStepTable.put(srcStateItem,new BitSet());
                    }
                    productionStepTable.get(srcStateItem).or(closures[item]);
                    reverseProductionStepTable[state].get(symbolAfterDot).set(item);
                }
            }
        }
    }

    /**
     * @see #productionStepTable
     * @param stateItem
     * @return the set of production steps for the given StateItem
     */
    public BitSet getProductionSteps(StateItem stateItem) {
        return productionStepTable.get(stateItem);
    }

    /**
     * @see #reverseProductionStepTable
     * @param state
     * @param nonTerminal
     * @return get the set of reverse production steps for the given state and nonterminal
     */
    public BitSet getReverseProductionSteps(int state, int nonTerminal){
        return reverseProductionStepTable[state].get(nonTerminal);
    }
}
